export const NEWS_INFO = [
  {
    id: 0,
    text: `В ночь с 31 января на 1 февраля сборная Казахстана по футзалу сыграет против Украины в 1/4 финала Евро-2022, передает Tengrinews.kz со ссылкой на Vesti.kz.
      Встреча пройдет в Амстердаме (Нидерланды) и начнется в 01.00 по времени Нур-Султана. Игру в прямом эфире покажет Qazsport.
      Трансляция будет доступна на официальном сайте телеканала.`
  },
  {
    id: 1,
    text: `Я работаю с React уже 5 лет, однако, когда дело касается структуры приложения или его внешнего вида (дизайна), сложно назвать какие-то универсальные подходы.
      Вместе с тем, существуют определенные приемы написания кода, которые позволяют обеспечить возможность долгосрочной поддержки и масштабируемости создаваемых проектов.
      Данная статья представляет собой своего рода набор правил разработки React-приложений, доказавших свою эффективность для меня и команд, с которыми я работал.
      Эти правила касаются компонентов, структуры приложения, тестирования, стилизации, управления состоянием и получения данных.
      Приводимые примеры намеренно упрощены с целью акцентирования внимания на общих принципах, а не на конкретной реализации.
      Предлагаемые подходы не являются истинной в последней инстанции. Это всего лишь мое мнение. Существует много разных способов решения одной и той же задачи.`
  },
  {
    id: 2,
    text: `Отдавайте предпочтение функциональным компонентам — они имеют более простой синтаксис. В них отсутствуют методы жизненного цикла, конструкторы и шаблонный код.
      Они позволяют реализовать такую же логику, что и классовые компоненты, но меньшими усилиями и более наглядным способом (код компонентов легче читать).
      До тех пор, пока вам не потребуются предохранители, используйте функциональные компоненты. Ментальная модель, которую надо держать в голове, будет намного проще.`
  },
  {
    id: 3,
    text: `Придерживайтесь одного стиля при создании компонентов.
      Помещайте вспомогательные функции в одно и тоже место, используйте одинаковый экспорт (по умолчанию или по названию) и одинаковый подход к именованию компонентов.
      У каждого подхода имеются свои преимущества и недостатки.
      Неважно, как вы экспортируете компоненты, в самом низу или при определении, просто придерживайтесь одного правила.`
  },
  {
    id: 4,
    text: `Всегда именуйте компоненты. Это помогает анализировать трассировку стека ошибки при использовании инструментов разработчика React.
      Это также помогает определить, разработкой какого компонента вы в данный момент занимаетесь.`
  },
  {
    id: 5,
    text: `Функции, которым не требуются данные, хранящиеся в компоненте, должны находиться за пределами (снаружи) компонента. 
      Для этого идеально подходит место перед определением компонента, чтобы код можно было изучать сверху вниз.
      Это уменьшает «шум» компонента — в нем остается только самое необходимое.`
  },
  {
    id: 6,
    text: `Компонент — это всего лишь функция, принимающая пропы и возвращающая разметку. Они следуют тем же принципам проектирования.
      Если функция выполняет слишком много задач, вынесите часть логики в другую функцию. 
      Тоже самое справедливо в отношении компонентов — если в компоненте содержится слишком сложный функционал, разделите его на несколько компонентов.
      Если часть разметки является сложной, включает циклы или условия — извлеките ее в отдельный компонент.
      Полагайтесь на пропы и коллбеки для взаимодействия и получения данных. Количество строк кода далеко не всегда является объективным критерием его качества. 
      Всегда помните об отзывчивости и абстракции.`
  },
  {
    id: 7,
    text: `При необходимости разъяснения происходящего создайте блок комментария и внесите туда необходимую информацию. 
      Разметка — это часть логики, так что, если вы чувствуете, что какую-то часть нужно прокомментировать, сделайте это.`
  },
  {
    id: 8,
    text: `Ошибка, возникшая в компоненте, не должна приводить к «поломке» пользовательского интерфейса. 
      Существуют редкие случаи, когда мы хотим, чтобы критическая ошибка привела к отказу в работоспособности приложения или перенаправлению. 
      В большинстве случаев, достаточно убрать определенный элемент с экрана.
      В функции, запрашивающей данные, у нас может быть любое количество блоков «try/catch». 
      Используйте предохранители не только на верхнем уровне приложения, но оборачивайте им каждый компонент, 
      в котором потенциально может быть выброшено исключение во избежание каскада ошибок.`
  },
  {
    id: 9,
    text: `Ответ на вопрос о количестве пропов является очень субъективным. 
      Количество пропов, передаваемых в компонент, коррелируется с количеством используемых компонентом переменных. 
      Чем больше пропов передается в компонент, тем выше его ответственность (имеется ввиду количество решаемых компонентом задач).
      Большое количество пропов может свидетельствовать о том, что компонент делает слишком много.
      Если в компонент передается больше 5 пропов, я задумываюсь о необходимости его разделения. 
      В некоторых случаях компоненту просто требуется много данных. Например, поле для ввода текста может нуждаться в большом количестве пропов. 
      С другой стороны, это верный признак того, что часть логики необходимо извлечь в отдельный компонент.
      Обратите внимание: чем больше пропов принимает компонент, чем чаще он перерисовывается.`
  },
  {
    id: 10,
    text: `Один из способов уменьшить количество передаваемых пропов — передавать объект вместо примитивов. 
      Вместо того, чтобы, например, передавать имя пользователя, его адрес электронной почты и т.д. по одному, можно их сгруппировать. 
      Это также облегчит процесс добавления новых данных`
  },
  {
    id: 11,
    text: `В некоторых случаях использование коротких вычислений (оператора «логическое И» — &&) для условного рендеринга может привести к отображению 0 в UI. 
      Во избежание этого используйте тернарный оператор. Единственным недостатком такого подхода является чуть большее количество кода.
      Оператор "&&" уменьшает количество кода, что здорово. 
      Тернарник является более «многословным», зато всегда работает корректно. 
      Кроме того, добавление альтернативного варианта при необходимости становится менее трудоемким.`
  },
  {
    id: 12,
    text: `Тернарные операторы становится трудно читать после первого уровня вложенности. 
    Несмотря на то, что тернарники экономят пространство, лучше явным и очевидным образом выражать свои намерения.`
  },
  {
    id: 13,
    text: `Перебор элементов списка — частая задача, обычно решаемая с помощью метода «map()».
      Как бы то ни было, в компоненте, содержащем много разметки, дополнительный отступ и синтаксис «map()» не способствуют повышению читаемости.
      При необходимости перебора элементов, извлеките их в отдельный компонент, даже если разметка небольшая. 
      Родительскому компоненту не нужны детали, ему достаточно «знать», что в определенном месте рендерится список.
      Итерацию можно оставить в компоненте, единственной задачей которого является отображение списка. 
      Если разметка списка является сложной и длинной, ее лучше извлечь в отдельный компонент.`
  },
  {
    id: 14,
    text: `Одним из способов определения пропов по умолчанию является добавления к компоненту атрибута «defaultProps».
      Однако, при таком подходе функция компонента и значения для ее аргументов будут находиться в разных местах.
      Поэтому более предпочтительным является присвоение «дефолтных» значений при деструктуризации пропов. 
      Это облегчает чтение кода сверху вниз и позволяет держать в одном месте определения и значения.`
  },
  {
    id: 15,
    text: `При необходимости извлечения логики или разметки из компонента, не помещайте их в функцию в том же компоненте. 
      Компонент — это функция. Значит, извлеченная часть кода будет представлена в виде вложенной функции.
      Это означает, что вложенная функция будет иметь доступ к состоянию и данным внешней функции. 
      Это делает код менее читаемым — что делает эта функция (за что она отвечает)?
      Перенесите вложенную функцию в отдельный компонент, присвойте ей имя и полагайтесь на пропы вместо замыкания.`
  },
]